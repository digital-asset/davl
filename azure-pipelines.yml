# Enable builds on all branches
trigger:
  # Build every commit as our release process relies on
  # the release process being built alone.
  batch: false
  branches:
    include:
      - master

# Enable PR triggers that target the master branch
pr:
  autoCancel: true # cancel previous builds on push
  branches:
    include:
      - master

jobs:
  - job: build_and_test
    timeoutInMinutes: 120
    pool:
      vmImage: "Ubuntu-16.04"
    steps:
      - checkout: self

      # Build and test TypeScripts
      - bash: |
          set -euo pipefail

          yarn --version
          yarn install
          yarn workspaces run build
          CI=yes yarn workspaces run test --ci --all
        displayName: build-and-test-ts

      # Install DAML SDK, possibly from cache
      - bash: |
          set -euo pipefail
          SDK_VERSION=$(cat v3/daml.yaml | grep sdk-version | awk '{print $2}')
          echo ${SDK_VERSION} > /tmp/daml-version
      - task: CacheBeta@1
        inputs:
          key: /tmp/daml-version
          path: /tmp/daml
          cacheHitVar: DAML_CACHE_HIT
      - bash: |
          set -euo pipefail
          DIR=$(pwd)

          # Install DAML SDK
          SDK_VERSION=$(cat v3/daml.yaml | grep sdk-version | awk '{print $2}')
          curl https://get.daml.com | sh -s $SDK_VERSION

          mkdir -p /tmp/daml
          cd $HOME/.daml
          tar czf /tmp/daml/sdk.tar.gz *
        condition: ne(variables.DAML_CACHE_HIT, 'true')
        displayName: daml-cache-miss
      - bash: |
          set -euo pipefail
          mkdir -p $HOME/.daml
          cd $HOME/.daml
          tar xzf /tmp/daml/sdk.tar.gz
        condition: eq(variables.DAML_CACHE_HIT, 'true')
        displayName: daml-cache-hit

      # Run DAML tests
      - bash: |
          set -euo pipefail

          export PATH="$PATH:~/.daml/bin"
          cd v3 && daml test
        displayName: run-daml-tests

      # Deploy
      - bash: |
          set -euo pipefail

          get_tag () {
              TZ=UTC git log -n1 --date=format-local:%Y%m%d%H%M --format=format:%cd-%h --abbrev=6 -- $@
          }
          tag_exists () {
              gcloud container images list-tags gcr.io/da-dev-pinacolada/$1 | grep -q $2
          }

          GCS_KEY=$(mktemp)
          cleanup () {
              rm -f $GCS_KEY
          }
          trap cleanup EXIT
          echo "$GOOGLE_APPLICATION_CREDENTIALS_CONTENT" > $GCS_KEY
          gcloud auth activate-service-account --key-file=$GCS_KEY
          gcloud auth configure-docker --quiet
          SDK_VERSION=$(cat v3/daml.yaml | grep '^sdk-version:' | awk '{print $2}')
          DAVL_VERSION=$(cat v3/daml.yaml | grep '^version:' | awk '{print $2}')
          DAVL_NAME=$(cat v3/daml.yaml | grep '^name:' | awk '{print $2}')

          SANDBOX_TAG=$(get_tag released v3/daml.yaml infra/sandbox.docker)
          if tag_exists sandbox $SANDBOX_TAG; then
              echo "sandbox $SANDBOX_TAG already exists."
          else
              echo "Building sandbox image version $SANDBOX_TAG..."
              SANDBOX_IMAGE=gcr.io/da-dev-pinacolada/sandbox:$SANDBOX_TAG
              DOCKER_DIR=$(mktemp -d)
              cp -r released $DOCKER_DIR/released
              cp $HOME/.daml/sdk/$SDK_VERSION/sandbox/sandbox.jar $DOCKER_DIR/sandbox.jar
              docker build -t $SANDBOX_IMAGE -f infra/sandbox.docker $DOCKER_DIR
              docker push $SANDBOX_IMAGE
              echo "Done building $SANDBOX_IMAGE."
          fi

          JSON_API_TAG=$(get_tag v3/daml.yaml infra/json-api.docker)
          if tag_exists json-api $JSON_API_TAG; then
              echo "json-api $JSON_API_TAG already exists."
          else
              echo "Building json-api image version $JSON_API_TAG..."
              JSON_API_IMAGE=gcr.io/da-dev-pinacolada/json-api:$JSON_API_TAG
              DOCKER_DIR=$(mktemp -d)
              cp $HOME/.daml/sdk/$SDK_VERSION/json-api/json-api-logback.xml $DOCKER_DIR/logback.xml
              cp $HOME/.daml/sdk/$SDK_VERSION/json-api/json-api.jar $DOCKER_DIR/json-api.jar
              docker build -t $JSON_API_IMAGE -f infra/json-api.docker $DOCKER_DIR
              docker push $JSON_API_IMAGE
              echo "Done building $JSON_API_IMAGE."
          fi

          UI_TAG=$(get_tag ui infra/nginx.docker infra/nginx.conf.sh)
          if tag_exists ui $UI_TAG; then
              echo "ui $UI_TAG already exists."
          else
              echo "Building ui image version $UI_TAG..."
              UI_IMAGE=gcr.io/da-dev-pinacolada/ui:$UI_TAG
              DOCKER_DIR=$(mktemp -d)
              (cd ui && yarn build)
              cp -r ui/build $DOCKER_DIR/ui
              cp infra/nginx.conf.sh $DOCKER_DIR/nginx.conf.sh
              docker build -t $UI_IMAGE -f infra/nginx.docker $DOCKER_DIR
              docker push $UI_IMAGE
              echo "Done building $UI_IMAGE."
          fi
        env:
          GOOGLE_APPLICATION_CREDENTIALS_CONTENT: $(GOOGLE_APPLICATION_CREDENTIALS_CONTENT)
        displayName: create-docker-images
        condition: in(variables['Build.SourceBranch'], 'refs/heads/master', 'master')
      - bash: |
          set -euo pipefail
          MESSAGE=$(git log --pretty=format:%s -n1)
          curl -XPOST \
               -i \
               -H 'Content-type: application/json' \
               --data "{\"text\":\"<!here> *FAILED* $(Agent.JobName): <https://dev.azure.com/digitalasset/davl/_build/results?buildId=$(Build.BuildId)|$MESSAGE>\n\"}" \
               $(Slack.URL)
        condition: and(failed(), in(variables['Build.SourceBranchName'], 'refs/heads/master', 'master'))
        displayName: tell-slack-if-failed
